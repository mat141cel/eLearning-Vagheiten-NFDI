---
title: "Forschungsdaten"
lang: de
date: today
date-modified: last-modified
date-format: "DD.MM.YYYY"
title-block: None 
---

## Was sind numismatische Forschungsdaten?
Forschungsdaten sind zunächst jede Art von digitalen Daten, die wissenschaftlich ausgewertet werden. Sie bilden die Grundlage wissenschaftlicher Arbeit und dokumentieren deren Ergebnisse.
Auf jeder Münze, egal aus welcher Zeit oder Region, sind die gleichen Daten zu finden. All diese Münzen aus unterschiedlichen Epochen haben beispielsweise das Feld Material, Dargestellte, Prägestätte und weitere. Auch wenn die Euromünze keine dargestellte Person hat und die Prägestätte der Münze von Napoleon III. unbekannt ist, ist dieses gerade nicht vorhanden sein dieser Informationen wichtig für die Interpretation der Münzdaten.

```{python}
#| echo: false
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
from pathlib import Path
from PIL import Image

# --- Configuration ---
images_dir = Path.cwd().parent / "assets" / "img"
images = [images_dir / "image_athens.jpg", images_dir /"image_napoleon.png", images_dir / "image_euro.jpg"]

image_positions = [1, 3, 5]
image_y = 2

# Attributes as single entries
attributes_data = [
    {"name": "Prägestätte", "x": 0.5, "y": 3.5, "direction": 1, "connected_to": [0,2]},
    {"name": "Dargestellte", "x": 4, "y": 3.5, "direction": 1, "connected_to": [0,1]},
    {"name": "Datierung", "x": 1, "y": 0.5, "direction": -1, "connected_to": [0,1,2]},
    {"name": "Material", "x": 3, "y": 0.5, "direction": -1, "connected_to": [1,1,2]}
]

# --- Helper ---
def load_img(path, size=(150, 150)):
    img = Image.open(path).convert("RGBA")
    img = img.resize(size, Image.LANCZOS)
    return OffsetImage(img, zoom=1)

# --- Figure ---
fig, ax = plt.subplots(figsize=(8,4))
ax.axis('off')

# Draw images
for x, img_path in zip(image_positions, images):
    ab = AnnotationBbox(load_img(img_path), (x, image_y), frameon=False)
    ax.add_artist(ab)

# Draw attributes and arrows
for attr in attributes_data:
    # Draw attribute node
    ax.text(attr["x"], attr["y"], attr["name"], ha='center', va='center', fontsize=10,
            bbox=dict(boxstyle="round,pad=0.4", facecolor="#F97307", edgecolor="#555555"))
    
    # Draw arrows from connected images
    for img_idx in attr["connected_to"]:
        img_x = image_positions[img_idx]
        ax.annotate("", xy=(attr["x"], attr["y"] - 0.15*attr["direction"]),
                    xytext=(img_x, image_y + 0.2*attr["direction"]),
                    arrowprops=dict(arrowstyle="-|>", color="#555555", lw=1.2))

# Layout
plt.xlim(0,6)
plt.ylim(0,4)
plt.tight_layout()
plt.show()
```

Links: https://ikmk.smb.museum/object?id=18214977 
Mitte: https://nat.museum-digital.de/object/73659
Rechts: https://ikmk.smb.museum/object?id=18203837



::: {.callout-note}
Dieses Bild wurde nicht händisch in einem Bildbearbeitungsprogramm erstellt. Es wurde direkt in Python programmiert und nutzt die Daten, die direkt aus den Münzdatenbanken kommen. Am Ende dieses und des nächsten Moduls können wir Schaubilder wie das obere mit Münzen aus verschiedenen Datenbanken selbst erstellen. 
:::

## Wie funktionieren Münzdaten

Grundsätzlich geht es darum, alle Informationen mit einer Münze zu verknüpfen. Die einfachste Form, Daten strukturiert zu speichern, ist eine Tabelle. Allerdings gibt es häufig auch Literatur zu einzelnen Münzen, so genannte Typenkataloge, die einzelnen Münzserien (Typen) beschreiben. 

::: {.callout-note collapse="true"}
## Was sind Typenkataloge?
Typenkataloge sind in der Numismatik seit dem 19. Jahrhundert die bevorzugte Art, Münzen zu ordnen. Maßstäbe setzten die British Museum Coinage (BMC) und darauf aufbauend Roman Imperial Coinage (RIC). Diese Bände enthalten alle bekannten Münzen der Zeit und alle für die [Münzbestimmung](https://pecunia.zaw.uni-heidelberg.de/NumiScience/muenzbestimmung) notwendigen Felder. Bei der digitalisierung der Kataloge wurden die Bilder und technischen Daten von Münzen direkt mit dem Eintrag verknüpft, was die Bestimmung erleichtert.
:::

Wenn man sich Daten als Tabellen vorstellt, bedeutet das, dass es zwei Tabellen braucht, eine mit Informationen für Münzen und eine mit Informationen zu ihrem Typ. Häufig sind Nutzer einer Datenbank auch an weiterführenden Informationen zu mit den Münzen verknüpften Orten oder Personen interessiert. Auch für diese Informationen ergibt es Sinn, eigene Tabellen zu erstellen, damit die Daten zentralisiert verändert werden können.

Der aktuelle Stand in der Darstellung von Münzen basiert auf drei Grundkonzepten, nämlich Ontologien, Normdaten und Knowledge-Graphen. In den folgenden Modulseiten werden diese Konzepte vorgestellt. Anschließend wird diskutiert, welche Probleme aktuelle Münzdaten trotzdem haben, und wie diese gelöst werden können.


### Was ist eine Ontologie?
Es gibt also eine fixe Anzahl an Datenfeldern, die für die Numismatik relevant sind. Diese wurden von der Numismatischen Forschungsgemeinschaft bereits standardisiert und stetig aktualisiert. International gültig ist die [Nomisma Ontology](http://www.nomisma.org/ontology). Auf diese Weise hat jede Münze unabhängig von der Sprache der Erfasser eine standardisiertes Datenfeld. Ontologien lassen sich einfach mit einer Graph-Metapher verstehen.

| Name | Gewicht in g | Durchmesser in mm | Webportal
|---------|:-----|-----|-----|
| https://ikmk.smb.museum/object?id=18201393      | 5,10    | 20  | http://numismatics.org/ocre/id/ric.5.post.29 |

: Münzdaten in tabellarischer Form {#tbl-muenzdaten tbl-colwidths="[20,10,10,20]"}




Das Feld Name weißt dabei eindeutig auf den Aureus des Postumus hin, die mit der Objektnummer: 18201393 beim Münzkabinett der Staatlichen Museen Berlin liegt. In der Darstellung als Graph wird wird jeder Eintrag zum einem Objekt

``` {python}
#| echo: False
import rdflib
from rdflib.extras.external_graph_libs import rdflib_to_networkx_multidigraph
import networkx as nx
import matplotlib.pyplot as plt

ttl_data = """
@prefix schema: <http://schema.org/> .
@prefix ns1: <https://ikmk.smb.museum/object/> .
@prefix ocre: <http://numismatics.org/ocre/id/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
 
ns1:18201393
    schema:Gewicht "5.10"^^xsd:decimal ;
    schema:Durchmesser "20"^^xsd:decimal ;
    schema:Webportal ocre:ric.5.post.29 .
"""

# Load RDF
g = rdflib.Graph()
g.parse(data=ttl_data, format='turtle')

# Convert to NetworkX
G = rdflib_to_networkx_multidigraph(g)

# Extract predicates as edge labels
edge_labels = {}
for s, p, o in g:
    edge_labels[(s, o)] = p.split('#')[-1] if '#' in p else p.split('/')[-1]

# Plot
pos = nx.spring_layout(G, scale=2)
nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=8, arrows=True)
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=7)

plt.show()

```

### Was sind Normdaten?

Bei Münzen gibt es also eine Liste an Datenfeldern, die immer vorhanden sind. In den meisten Datenbanken werden diese Datenfelder normiert erfasst. (LINK oder Erklärfenster Normierung / Normdaten) Auch diese sind in der Ontologie von Nomisma hinterlegt. Sie haben den Typ Class, die Prädikate haben den Typ Property und haben immer ein has vor dem Text. 
