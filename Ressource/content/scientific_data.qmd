---
title: "Forschungsdaten"
lang: de
date: today
date-modified: last-modified
date-format: "DD.MM.YYYY"
title-block: None 
---

## Was sind numismatische Forschungsdaten?
Forschungsdaten sind zunächst jede Art von digitalen Daten, die wissenschaftlich ausgewertet werden. Sie sind Grundlage und Ergebnis wissenschaftlicher Arbeit.

Für jede Münze, egal aus welcher Zeit oder Region, gibt es eine fixe Anzahl relevanter Datenfelder. All diese Münzen aus unterschiedlichen Epochen haben beispielsweise das Informationen zu Material, Dargestellten, Prägestätten. Auch wenn die Euromünze keine dargestellte Person hat und die Prägestätte der Münze von Napoleon III. unbekannt ist, ist dieses gerade nicht vorhanden sein dieser Informationen wichtig für die Interpretation der Münzdaten. 

```{python}
#| echo: false
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
from pathlib import Path
from PIL import Image

# --- Configuration ---
images_dir = Path.cwd().parent / "assets" / "img"
images = [images_dir / "image_athens.jpg", images_dir /"image_napoleon.png", images_dir / "image_euro.jpg"]

image_positions = [1, 3, 5]
image_y = 2

# Attributes as single entries
attributes_data = [
    {"name": "Prägestätte", "x": 0.5, "y": 3.5, "direction": 1, "connected_to": [0,2]},
    {"name": "Dargestellte", "x": 4, "y": 3.5, "direction": 1, "connected_to": [0,1]},
    {"name": "Datierung", "x": 1, "y": 0.5, "direction": -1, "connected_to": [0,1,2]},
    {"name": "Material", "x": 3, "y": 0.5, "direction": -1, "connected_to": [1,1,2]}
]

# --- Helper ---
def load_img(path, size=(150, 150)):
    img = Image.open(path).convert("RGBA")
    img = img.resize(size, Image.LANCZOS)
    return OffsetImage(img, zoom=1)

# --- Figure ---
fig, ax = plt.subplots(figsize=(8,4))
ax.axis('off')

# Draw images
for x, img_path in zip(image_positions, images):
    ab = AnnotationBbox(load_img(img_path), (x, image_y), frameon=False)
    ax.add_artist(ab)

# Draw attributes and arrows
for attr in attributes_data:
    # Draw attribute node
    ax.text(attr["x"], attr["y"], attr["name"], ha='center', va='center', fontsize=10,
            bbox=dict(boxstyle="round,pad=0.4", facecolor="#F97307", edgecolor="#555555"))
    
    # Draw arrows from connected images
    for img_idx in attr["connected_to"]:
        img_x = image_positions[img_idx]
        ax.annotate("", xy=(attr["x"], attr["y"] - 0.15*attr["direction"]),
                    xytext=(img_x, image_y + 0.2*attr["direction"]),
                    arrowprops=dict(arrowstyle="-|>", color="#555555", lw=1.2))

# Layout
plt.xlim(0,6)
plt.ylim(0,4)
plt.tight_layout()
plt.show()
```

Links: https://ikmk.smb.museum/object?id=18214977 
Mitte: https://nat.museum-digital.de/object/73659
Rechts: https://ikmk.smb.museum/object?id=18203837



::: {.callout-note}
Dieses Bild wurde nicht händisch in einem Bildbearbeitungsprogramm erstellt. Es wurde direkt in Python programmiert und nutzt die Daten, die direkt aus den Münzdatenbanken kommen. Am Ende dieses und des nächsten Moduls können wir Schaubilder wie das obere mit Münzen aus verschiedenen Datenbanken selbst erstellen. 
:::

## Wie können wir uns Münzdaten vorstellen

Die einfachste Form, Münzdaten strukturiert zu speichern, ist eine Tabelle. Die Reihen stehen für die einzelne Münze, die Spalten für bestimmte Kategorien, die für die Münze erfasst werden. Das folgende Beispiel zeigt dabei, dass eine Tabelle für Münzdaten nicht ausreicht. 


| Name | Gewicht in g | Durchmesser in mm | Webportal
|---------|:-----|-----|-----|
| https://ikmk.smb.museum/object?id=18201393      | 5,10    | 20  | http://numismatics.org/ocre/id/ric.5.post.29 |

: Münzdaten in tabellarischer Form {#tbl-muenzdaten tbl-colwidths="[20,10,10,20]"}

Das Feld Name weißt dabei eindeutig auf den Aureus des Postumus hin, die mit der Objektnummer: 18201393 beim Münzkabinett der Staatlichen Museen Berlin liegt. Diese Münze hat unter anderem ein spezifisches Gewicht und einen spezifischen Durchmesser. Außerdem gibt häufig Literatur zu einzelnen Münzen, so genannte Typenkataloge, die einzelnen Münzserien (Typen) beschreiben. Im vorliegenden Fall ist das der Typ Roman Imperial Coinage Band 5, Postumus, Nummer 29.
 
::: {.callout-note collapse="true"}
## Was sind Typenkataloge?
Typenkataloge sind in der Numismatik seit dem 19. Jahrhundert die bevorzugte Art, Münzen zu ordnen. Maßstäbe setzten die British Museum Coinage (BMC) und darauf aufbauend Roman Imperial Coinage (RIC). Diese Bände enthalten alle bekannten Münzen der Zeit und alle für die [Münzbestimmung](https://pecunia.zaw.uni-heidelberg.de/NumiScience/muenzbestimmung) notwendigen Felder. Bei der digitalisierung der Kataloge wurden die Bilder und technischen Daten von Münzen direkt mit dem Eintrag verknüpft, was die Bestimmung erleichtert.
:::

Es ergibt Sinn die Informationen, die dem Münztyp zugeordnet werden, in einer eigenen Tabelle zu speichern. Einerseits kann so die Herkunft der Daten verstanden werden, andererseits können Anpassungen zentral vorgenommen werden. Häufig sind Nutzer einer Datenbank auch an weiterführenden Informationen zu mit den Münzen verknüpften Orten oder Personen interessiert. Auch für diese Informationen sollten eigene Tabellen erstellt werden, damit die Daten zentralisiert verändert werden können. So erhalten die Münzdaten komplexe Vernetzungen.


### Was ist eine Ontologie?

Sobald Münzdaten aus komplexen Verbindungen verschiedener Datenquellen bestehen, eignet sich eine andere Darstellungsform als Tabellen: Graphen.
Für die Darstellung als Graph braucht muss das Namensfeld als zentrales Objekt definiert werden, die mit den anderen Werten über die jeweiligen Prädikate der Zeilenüberschriften verbunden sind. Das vorige Beispiel würde als Graph wie folgt aussehen:


``` {python}
#| echo: False
import rdflib
from rdflib.extras.external_graph_libs import rdflib_to_networkx_multidigraph
import networkx as nx
import matplotlib.pyplot as plt

ttl_data = """
@prefix schema: <http://schema.org/> .
@prefix ns1: <https://ikmk.smb.museum/object/> .
@prefix ocre: <http://numismatics.org/ocre/id/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
 
ns1:18201393
    schema:Gewicht "5.10"^^xsd:decimal ;
    schema:Durchmesser "20"^^xsd:decimal ;
    schema:Webportal ocre:ric.5.post.29 .
"""

# Load RDF
g = rdflib.Graph()
g.parse(data=ttl_data, format='turtle')

# Convert to NetworkX
G = rdflib_to_networkx_multidigraph(g)

# Extract predicates as edge labels
edge_labels = {}
for s, p, o in g:
    edge_labels[(s, o)] = p.split('#')[-1] if '#' in p else p.split('/')[-1]

# Plot
pos = nx.spring_layout(G, seed=123, scale=3)
nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=8, arrows=True)
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=7)

plt.show()
```

### Was ist eine Ontologie?

Wenn Daten auf diese Weise dargestellt werden, zeigt sich, an welchen Stellen eine Standardisierung notwendig ist. Das Objekt Münze braucht eine festgelegte Anzahl an Feldern, die dem Objekt zugeordnet werden kann und der Inhalt der Felder sollte ebenfalls normiert sein. So sollte zum Beispiel nicht eine Institution den Link zum Typportal mit "http://numismatics.org/ocre..."  angeben, während eine andere "http://www.numismatics.org/ocre..." schreibt.

Die Graphdarstellung hilft auch, die Informationen aus Typenportalen separat zu speichern und mit dem Datensatz zu verknüpfen. die mit der Münze verknüpfte OCRE-ID hat beispielsweise ebenfalls einen Graph.

Um Herauszufinden, wie dieser Graph aussieht, öffnen sie das interaktive Modul in Colab.

Diese Standardisierung ist in der Numismatik bereits weitgehend abgeschlossen. International gültig ist die [Nomisma Ontology](http://www.nomisma.org/ontology). Auf diese Weise hat jede Münze unabhängig von der Sprache der Erfasser eine standardisiertes Datenfeld.


### Was sind Normdaten?

Bei Münzen gibt es also eine Liste an Datenfeldern, die immer vorhanden sind. In den meisten Datenbanken werden diese Datenfelder normiert erfasst. (LINK oder Erklärfenster Normierung / Normdaten) Auch diese sind in der Ontologie von Nomisma hinterlegt. Sie haben den Typ Class, die Prädikate haben den Typ Property und haben immer ein has vor dem Text. 
